import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import _toPropertyKey from "@babel/runtime/helpers/esm/toPropertyKey";
import * as React from 'react';
import { useGridApiMethod } from '../../utils/useGridApiMethod';
import { GridEvents } from '../../../models/events';
export var GRID_DEFAULT_STRATEGY = 'none';
export var GRID_STRATEGIES_PROCESSORS = {
  rowTreeCreation: 'rowTree',
  filtering: 'rowTree',
  sorting: 'rowTree'
};

/**
 * Implements a variant of the Strategy Pattern (see https://en.wikipedia.org/wiki/Strategy_pattern)
 *
 * Some plugins contain custom logic that must only be run if the right strategy is active.
 * For instance, the tree data plugin has:
 * - custom row tree creation algorithm.
 * - custom sorting algorithm.
 * - custom filtering algorithm.
 *
 * These plugins must use:
 * - `apiRef.current.unstable_registerStrategyProcessor` to register their processors.
 * - `apiRef.current.unstable_setStrategyAvailability` to tell if their strategy can be used.
 *
 * Some hooks need to run the custom logic of the active strategy.
 * For instance, the `useGridFiltering` wants to run:
 * - the tree data filtering if the tree data is the current way of grouping rows.
 * - the row grouping filtering if the row grouping is the current way of grouping rows.
 * - the flat filtering if there is no grouping of the rows (equivalent to the "none" strategy).
 *
 * These hooks must use:
 * - `apiRef.current.unstable_applyStrategyProcessor` to run a processor.
 * - `GridEvents.strategyAvailabilityChange` to update something when the active strategy changes.
 *    Warning: Be careful not to apply the processor several times.
 *    For instance `GridEvents.rowsSet` is fired by `useGridRows` whenever the active strategy changes.
 *    So listening to both would most likely run your logic twice.
 * - `GridEvents.activeStrategyProcessorChange` to update something when the processor of the active strategy changes
 *
 * Each processor name is part of a strategy group which can only have one active strategy at the time.
 */
export var useGridStrategyProcessing = function useGridStrategyProcessing(apiRef) {
  var availableStrategies = React.useRef(new Map());
  var strategiesCache = React.useRef({});
  var registerStrategyProcessor = React.useCallback(function (strategyName, processorName, processor) {
    var cleanup = function cleanup() {
      var _ref = strategiesCache.current[processorName],
          removedPreProcessor = _ref[strategyName],
          otherProcessors = _objectWithoutProperties(_ref, [strategyName].map(_toPropertyKey));

      strategiesCache.current[processorName] = otherProcessors;
    };

    if (!strategiesCache.current[processorName]) {
      strategiesCache.current[processorName] = {};
    }

    var groupPreProcessors = strategiesCache.current[processorName];
    var previousProcessor = groupPreProcessors[strategyName];
    groupPreProcessors[strategyName] = processor;

    if (!previousProcessor || previousProcessor === processor) {
      return cleanup;
    }

    if (strategyName === apiRef.current.unstable_getActiveStrategy(GRID_STRATEGIES_PROCESSORS[processorName])) {
      apiRef.current.publishEvent(GridEvents.activeStrategyProcessorChange, processorName);
    }

    return cleanup;
  }, [apiRef]);
  var applyStrategyProcessor = React.useCallback(function (processorName, params) {
    var activeStrategy = apiRef.current.unstable_getActiveStrategy(GRID_STRATEGIES_PROCESSORS[processorName]);

    if (activeStrategy == null) {
      throw new Error("Can't apply a strategy processor before defining an active strategy");
    }

    var groupCache = strategiesCache.current[processorName];

    if (!groupCache || !groupCache[activeStrategy]) {
      throw new Error("No processor found for processor \"".concat(processorName, "\" on strategy \"").concat(activeStrategy, "\""));
    }

    var processor = groupCache[activeStrategy];
    return processor(params);
  }, [apiRef]);
  var getActiveStrategy = React.useCallback(function (strategyGroup) {
    var _availableStrategyEnt;

    var strategyEntries = Array.from(availableStrategies.current.entries());
    var availableStrategyEntry = strategyEntries.find(function (_ref2) {
      var _ref3 = _slicedToArray(_ref2, 2),
          strategy = _ref3[1];

      if (strategy.group !== strategyGroup) {
        return false;
      }

      return strategy.isAvailable();
    });
    return (_availableStrategyEnt = availableStrategyEntry == null ? void 0 : availableStrategyEntry[0]) != null ? _availableStrategyEnt : GRID_DEFAULT_STRATEGY;
  }, []);
  var setStrategyAvailability = React.useCallback(function (strategyGroup, strategyName, isAvailable) {
    availableStrategies.current.set(strategyName, {
      group: strategyGroup,
      isAvailable: isAvailable
    });
    apiRef.current.publishEvent(GridEvents.strategyAvailabilityChange);
  }, [apiRef]);
  var strategyProcessingApi = {
    unstable_registerStrategyProcessor: registerStrategyProcessor,
    unstable_applyStrategyProcessor: applyStrategyProcessor,
    unstable_getActiveStrategy: getActiveStrategy,
    unstable_setStrategyAvailability: setStrategyAvailability
  };
  useGridApiMethod(apiRef, strategyProcessingApi, 'GridStrategyProcessing');
};