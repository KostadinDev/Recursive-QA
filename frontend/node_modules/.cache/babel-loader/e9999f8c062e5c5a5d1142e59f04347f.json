{"ast":null,"code":"import _slicedToArray from \"/Users/kostadindev/PycharmProjects/rfc_qa_generation/recursive-qa/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _toPropertyKey from \"@babel/runtime/helpers/esm/toPropertyKey\";\nimport * as React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { GridEvents } from '../../../models/events';\nexport var GRID_DEFAULT_STRATEGY = 'none';\nexport var GRID_STRATEGIES_PROCESSORS = {\n  rowTreeCreation: 'rowTree',\n  filtering: 'rowTree',\n  sorting: 'rowTree'\n};\n/**\n * Implements a variant of the Strategy Pattern (see https://en.wikipedia.org/wiki/Strategy_pattern)\n *\n * Some plugins contain custom logic that must only be run if the right strategy is active.\n * For instance, the tree data plugin has:\n * - custom row tree creation algorithm.\n * - custom sorting algorithm.\n * - custom filtering algorithm.\n *\n * These plugins must use:\n * - `apiRef.current.unstable_registerStrategyProcessor` to register their processors.\n * - `apiRef.current.unstable_setStrategyAvailability` to tell if their strategy can be used.\n *\n * Some hooks need to run the custom logic of the active strategy.\n * For instance, the `useGridFiltering` wants to run:\n * - the tree data filtering if the tree data is the current way of grouping rows.\n * - the row grouping filtering if the row grouping is the current way of grouping rows.\n * - the flat filtering if there is no grouping of the rows (equivalent to the \"none\" strategy).\n *\n * These hooks must use:\n * - `apiRef.current.unstable_applyStrategyProcessor` to run a processor.\n * - `GridEvents.strategyAvailabilityChange` to update something when the active strategy changes.\n *    Warning: Be careful not to apply the processor several times.\n *    For instance `GridEvents.rowsSet` is fired by `useGridRows` whenever the active strategy changes.\n *    So listening to both would most likely run your logic twice.\n * - `GridEvents.activeStrategyProcessorChange` to update something when the processor of the active strategy changes\n *\n * Each processor name is part of a strategy group which can only have one active strategy at the time.\n */\n\nexport var useGridStrategyProcessing = function useGridStrategyProcessing(apiRef) {\n  var availableStrategies = React.useRef(new Map());\n  var strategiesCache = React.useRef({});\n  var registerStrategyProcessor = React.useCallback(function (strategyName, processorName, processor) {\n    var cleanup = function cleanup() {\n      var _ref = strategiesCache.current[processorName],\n          otherProcessors = _objectWithoutPropertiesLoose(_ref, [strategyName].map(_toPropertyKey));\n\n      strategiesCache.current[processorName] = otherProcessors;\n    };\n\n    if (!strategiesCache.current[processorName]) {\n      strategiesCache.current[processorName] = {};\n    }\n\n    var groupPreProcessors = strategiesCache.current[processorName];\n    var previousProcessor = groupPreProcessors[strategyName];\n    groupPreProcessors[strategyName] = processor;\n\n    if (!previousProcessor || previousProcessor === processor) {\n      return cleanup;\n    }\n\n    if (strategyName === apiRef.current.unstable_getActiveStrategy(GRID_STRATEGIES_PROCESSORS[processorName])) {\n      apiRef.current.publishEvent(GridEvents.activeStrategyProcessorChange, processorName);\n    }\n\n    return cleanup;\n  }, [apiRef]);\n  var applyStrategyProcessor = React.useCallback(function (processorName, params) {\n    var activeStrategy = apiRef.current.unstable_getActiveStrategy(GRID_STRATEGIES_PROCESSORS[processorName]);\n\n    if (activeStrategy == null) {\n      throw new Error(\"Can't apply a strategy processor before defining an active strategy\");\n    }\n\n    var groupCache = strategiesCache.current[processorName];\n\n    if (!groupCache || !groupCache[activeStrategy]) {\n      throw new Error(\"No processor found for processor \\\"\".concat(processorName, \"\\\" on strategy \\\"\").concat(activeStrategy, \"\\\"\"));\n    }\n\n    var processor = groupCache[activeStrategy];\n    return processor(params);\n  }, [apiRef]);\n  var getActiveStrategy = React.useCallback(function (strategyGroup) {\n    var _availableStrategyEnt;\n\n    var strategyEntries = Array.from(availableStrategies.current.entries());\n    var availableStrategyEntry = strategyEntries.find(function (_ref2) {\n      var _ref3 = _slicedToArray(_ref2, 2),\n          strategy = _ref3[1];\n\n      if (strategy.group !== strategyGroup) {\n        return false;\n      }\n\n      return strategy.isAvailable();\n    });\n    return (_availableStrategyEnt = availableStrategyEntry == null ? void 0 : availableStrategyEntry[0]) != null ? _availableStrategyEnt : GRID_DEFAULT_STRATEGY;\n  }, []);\n  var setStrategyAvailability = React.useCallback(function (strategyGroup, strategyName, isAvailable) {\n    availableStrategies.current.set(strategyName, {\n      group: strategyGroup,\n      isAvailable: isAvailable\n    });\n    apiRef.current.publishEvent(GridEvents.strategyAvailabilityChange);\n  }, [apiRef]);\n  var strategyProcessingApi = {\n    unstable_registerStrategyProcessor: registerStrategyProcessor,\n    unstable_applyStrategyProcessor: applyStrategyProcessor,\n    unstable_getActiveStrategy: getActiveStrategy,\n    unstable_setStrategyAvailability: setStrategyAvailability\n  };\n  useGridApiMethod(apiRef, strategyProcessingApi, 'GridStrategyProcessing');\n};","map":{"version":3,"sources":["/Users/kostadindev/PycharmProjects/rfc_qa_generation/recursive-qa/frontend/node_modules/@mui/x-data-grid/hooks/core/strategyProcessing/useGridStrategyProcessing.js"],"names":["_objectWithoutPropertiesLoose","_toPropertyKey","React","useGridApiMethod","GridEvents","GRID_DEFAULT_STRATEGY","GRID_STRATEGIES_PROCESSORS","rowTreeCreation","filtering","sorting","useGridStrategyProcessing","apiRef","availableStrategies","useRef","Map","strategiesCache","registerStrategyProcessor","useCallback","strategyName","processorName","processor","cleanup","_ref","current","otherProcessors","map","groupPreProcessors","previousProcessor","unstable_getActiveStrategy","publishEvent","activeStrategyProcessorChange","applyStrategyProcessor","params","activeStrategy","Error","groupCache","getActiveStrategy","strategyGroup","_availableStrategyEnt","strategyEntries","Array","from","entries","availableStrategyEntry","find","strategy","group","isAvailable","setStrategyAvailability","set","strategyAvailabilityChange","strategyProcessingApi","unstable_registerStrategyProcessor","unstable_applyStrategyProcessor","unstable_setStrategyAvailability"],"mappings":"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","sourcesContent":["import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _toPropertyKey from \"@babel/runtime/helpers/esm/toPropertyKey\";\nimport * as React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { GridEvents } from '../../../models/events';\nexport const GRID_DEFAULT_STRATEGY = 'none';\nexport const GRID_STRATEGIES_PROCESSORS = {\n  rowTreeCreation: 'rowTree',\n  filtering: 'rowTree',\n  sorting: 'rowTree'\n};\n\n/**\n * Implements a variant of the Strategy Pattern (see https://en.wikipedia.org/wiki/Strategy_pattern)\n *\n * Some plugins contain custom logic that must only be run if the right strategy is active.\n * For instance, the tree data plugin has:\n * - custom row tree creation algorithm.\n * - custom sorting algorithm.\n * - custom filtering algorithm.\n *\n * These plugins must use:\n * - `apiRef.current.unstable_registerStrategyProcessor` to register their processors.\n * - `apiRef.current.unstable_setStrategyAvailability` to tell if their strategy can be used.\n *\n * Some hooks need to run the custom logic of the active strategy.\n * For instance, the `useGridFiltering` wants to run:\n * - the tree data filtering if the tree data is the current way of grouping rows.\n * - the row grouping filtering if the row grouping is the current way of grouping rows.\n * - the flat filtering if there is no grouping of the rows (equivalent to the \"none\" strategy).\n *\n * These hooks must use:\n * - `apiRef.current.unstable_applyStrategyProcessor` to run a processor.\n * - `GridEvents.strategyAvailabilityChange` to update something when the active strategy changes.\n *    Warning: Be careful not to apply the processor several times.\n *    For instance `GridEvents.rowsSet` is fired by `useGridRows` whenever the active strategy changes.\n *    So listening to both would most likely run your logic twice.\n * - `GridEvents.activeStrategyProcessorChange` to update something when the processor of the active strategy changes\n *\n * Each processor name is part of a strategy group which can only have one active strategy at the time.\n */\nexport const useGridStrategyProcessing = apiRef => {\n  const availableStrategies = React.useRef(new Map());\n  const strategiesCache = React.useRef({});\n  const registerStrategyProcessor = React.useCallback((strategyName, processorName, processor) => {\n    const cleanup = () => {\n      const _ref = strategiesCache.current[processorName],\n            otherProcessors = _objectWithoutPropertiesLoose(_ref, [strategyName].map(_toPropertyKey));\n\n      strategiesCache.current[processorName] = otherProcessors;\n    };\n\n    if (!strategiesCache.current[processorName]) {\n      strategiesCache.current[processorName] = {};\n    }\n\n    const groupPreProcessors = strategiesCache.current[processorName];\n    const previousProcessor = groupPreProcessors[strategyName];\n    groupPreProcessors[strategyName] = processor;\n\n    if (!previousProcessor || previousProcessor === processor) {\n      return cleanup;\n    }\n\n    if (strategyName === apiRef.current.unstable_getActiveStrategy(GRID_STRATEGIES_PROCESSORS[processorName])) {\n      apiRef.current.publishEvent(GridEvents.activeStrategyProcessorChange, processorName);\n    }\n\n    return cleanup;\n  }, [apiRef]);\n  const applyStrategyProcessor = React.useCallback((processorName, params) => {\n    const activeStrategy = apiRef.current.unstable_getActiveStrategy(GRID_STRATEGIES_PROCESSORS[processorName]);\n\n    if (activeStrategy == null) {\n      throw new Error(\"Can't apply a strategy processor before defining an active strategy\");\n    }\n\n    const groupCache = strategiesCache.current[processorName];\n\n    if (!groupCache || !groupCache[activeStrategy]) {\n      throw new Error(`No processor found for processor \"${processorName}\" on strategy \"${activeStrategy}\"`);\n    }\n\n    const processor = groupCache[activeStrategy];\n    return processor(params);\n  }, [apiRef]);\n  const getActiveStrategy = React.useCallback(strategyGroup => {\n    var _availableStrategyEnt;\n\n    const strategyEntries = Array.from(availableStrategies.current.entries());\n    const availableStrategyEntry = strategyEntries.find(([, strategy]) => {\n      if (strategy.group !== strategyGroup) {\n        return false;\n      }\n\n      return strategy.isAvailable();\n    });\n    return (_availableStrategyEnt = availableStrategyEntry == null ? void 0 : availableStrategyEntry[0]) != null ? _availableStrategyEnt : GRID_DEFAULT_STRATEGY;\n  }, []);\n  const setStrategyAvailability = React.useCallback((strategyGroup, strategyName, isAvailable) => {\n    availableStrategies.current.set(strategyName, {\n      group: strategyGroup,\n      isAvailable\n    });\n    apiRef.current.publishEvent(GridEvents.strategyAvailabilityChange);\n  }, [apiRef]);\n  const strategyProcessingApi = {\n    unstable_registerStrategyProcessor: registerStrategyProcessor,\n    unstable_applyStrategyProcessor: applyStrategyProcessor,\n    unstable_getActiveStrategy: getActiveStrategy,\n    unstable_setStrategyAvailability: setStrategyAvailability\n  };\n  useGridApiMethod(apiRef, strategyProcessingApi, 'GridStrategyProcessing');\n};"]},"metadata":{},"sourceType":"module"}