{"ast":null,"code":"import _toConsumableArray from \"/Users/kostadindev/PycharmProjects/rfc_qa_generation/recursive-qa/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/kostadindev/PycharmProjects/rfc_qa_generation/recursive-qa/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { DEFAULT_GRID_COL_TYPE_KEY, getGridDefaultColumnTypes } from '../../../models';\nimport { gridColumnsSelector, gridColumnVisibilityModelSelector } from './gridColumnsSelector';\nimport { clamp } from '../../../utils/utils';\nexport var COLUMNS_DIMENSION_PROPERTIES = ['maxWidth', 'minWidth', 'width', 'flex'];\nexport var computeColumnTypes = function computeColumnTypes() {\n  var customColumnTypes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var mergedColumnTypes = _extends({}, getGridDefaultColumnTypes());\n\n  Object.entries(customColumnTypes).forEach(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        colType = _ref2[0],\n        colTypeDef = _ref2[1];\n\n    if (mergedColumnTypes[colType]) {\n      mergedColumnTypes[colType] = _extends({}, mergedColumnTypes[colType], colTypeDef);\n    } else {\n      mergedColumnTypes[colType] = _extends({}, mergedColumnTypes[colTypeDef.extendType || DEFAULT_GRID_COL_TYPE_KEY], colTypeDef);\n    }\n  });\n  return mergedColumnTypes;\n};\n/**\n * Computes width for flex columns.\n * Based on CSS Flexbox specification:\n * https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n */\n\nexport function computeFlexColumnsWidth(_ref3) {\n  var initialFreeSpace = _ref3.initialFreeSpace,\n      totalFlexUnits = _ref3.totalFlexUnits,\n      flexColumns = _ref3.flexColumns;\n  var flexColumnsLookup = {\n    all: {},\n    frozenFields: [],\n    freeze: function freeze(field) {\n      var value = flexColumnsLookup.all[field];\n\n      if (value && value.frozen !== true) {\n        flexColumnsLookup.all[field].frozen = true;\n        flexColumnsLookup.frozenFields.push(field);\n      }\n    }\n  }; // Step 5 of https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n\n  function loopOverFlexItems() {\n    // 5a: If all the flex items on the line are frozen, free space has been distributed.\n    if (flexColumnsLookup.frozenFields.length === flexColumns.length) {\n      return;\n    }\n\n    var violationsLookup = {\n      min: {},\n      max: {}\n    };\n    var remainingFreeSpace = initialFreeSpace;\n    var flexUnits = totalFlexUnits;\n    var totalViolation = 0; // 5b: Calculate the remaining free space\n\n    flexColumnsLookup.frozenFields.forEach(function (field) {\n      remainingFreeSpace -= flexColumnsLookup.all[field].computedWidth;\n      flexUnits -= flexColumnsLookup.all[field].flex;\n    });\n\n    for (var i = 0; i < flexColumns.length; i += 1) {\n      var column = flexColumns[i];\n\n      if (flexColumnsLookup.all[column.field] && flexColumnsLookup.all[column.field].frozen === true) {\n        // eslint-disable-next-line no-continue\n        continue;\n      } // 5c: Distribute remaining free space proportional to the flex factors\n\n\n      var widthPerFlexUnit = remainingFreeSpace / flexUnits;\n      var computedWidth = widthPerFlexUnit * column.flex; // 5d: Fix min/max violations\n\n      if (computedWidth < column.minWidth) {\n        totalViolation += column.minWidth - computedWidth;\n        computedWidth = column.minWidth;\n        violationsLookup.min[column.field] = true;\n      } else if (computedWidth > column.maxWidth) {\n        totalViolation += column.maxWidth - computedWidth;\n        computedWidth = column.maxWidth;\n        violationsLookup.max[column.field] = true;\n      }\n\n      flexColumnsLookup.all[column.field] = {\n        frozen: false,\n        computedWidth: computedWidth,\n        flex: column.flex\n      };\n    } // 5e: Freeze over-flexed items\n\n\n    if (totalViolation < 0) {\n      // Freeze all the items with max violations\n      Object.keys(violationsLookup.max).forEach(function (field) {\n        flexColumnsLookup.freeze(field);\n      });\n    } else if (totalViolation > 0) {\n      // Freeze all the items with min violations\n      Object.keys(violationsLookup.min).forEach(function (field) {\n        flexColumnsLookup.freeze(field);\n      });\n    } else {\n      // Freeze all items\n      flexColumns.forEach(function (_ref4) {\n        var field = _ref4.field;\n        flexColumnsLookup.freeze(field);\n      });\n    } // 5f: Return to the start of this loop\n\n\n    loopOverFlexItems();\n  }\n\n  loopOverFlexItems();\n  return flexColumnsLookup.all;\n}\n/**\n * Compute the `computedWidth` (ie: the width the column should have during rendering) based on the `width` / `flex` / `minWidth` / `maxWidth` properties of `GridColDef`.\n * The columns already have been merged with there `type` default values for `minWidth`, `maxWidth` and `width`, thus the `!` for those properties below.\n * TODO: Unit test this function in depth and only keep basic cases for the whole grid testing.\n * TODO: Improve the `GridColDef` typing to reflect the fact that `minWidth` / `maxWidth` and `width` can't be null after the merge with the `type` default values.\n */\n\nexport var hydrateColumnsWidth = function hydrateColumnsWidth(rawState, viewportInnerWidth) {\n  var columnsLookup = {};\n  var totalFlexUnits = 0;\n  var widthAllocatedBeforeFlex = 0;\n  var flexColumns = []; // For the non-flex columns, compute their width\n  // For the flex columns, compute there minimum width and how much width must be allocated during the flex allocation\n\n  rawState.all.forEach(function (columnField) {\n    var newColumn = _extends({}, rawState.lookup[columnField]);\n\n    if (rawState.columnVisibilityModel[columnField] === false) {\n      newColumn.computedWidth = 0;\n    } else {\n      var computedWidth;\n\n      if (newColumn.flex && newColumn.flex > 0) {\n        totalFlexUnits += newColumn.flex;\n        computedWidth = 0;\n        flexColumns.push(newColumn);\n      } else {\n        computedWidth = clamp(newColumn.width, newColumn.minWidth, newColumn.maxWidth);\n      }\n\n      widthAllocatedBeforeFlex += computedWidth;\n      newColumn.computedWidth = computedWidth;\n    }\n\n    columnsLookup[columnField] = newColumn;\n  });\n  var initialFreeSpace = Math.max(viewportInnerWidth - widthAllocatedBeforeFlex, 0); // Allocate the remaining space to the flex columns\n\n  if (totalFlexUnits > 0 && viewportInnerWidth > 0) {\n    var computedColumnWidths = computeFlexColumnsWidth({\n      initialFreeSpace: initialFreeSpace,\n      totalFlexUnits: totalFlexUnits,\n      flexColumns: flexColumns\n    });\n    Object.keys(computedColumnWidths).forEach(function (field) {\n      columnsLookup[field].computedWidth = computedColumnWidths[field].computedWidth;\n    });\n  }\n\n  return _extends({}, rawState, {\n    lookup: columnsLookup\n  });\n};\nvar columnTypeWarnedOnce = false;\n/**\n * Apply the order and the dimensions of the initial state.\n * The columns not registered in `orderedFields` will be placed after the imported columns.\n */\n\nexport var applyInitialState = function applyInitialState(columnsState, initialState) {\n  if (!initialState) {\n    return columnsState;\n  }\n\n  var _initialState$ordered = initialState.orderedFields,\n      orderedFields = _initialState$ordered === void 0 ? [] : _initialState$ordered,\n      _initialState$dimensi = initialState.dimensions,\n      dimensions = _initialState$dimensi === void 0 ? {} : _initialState$dimensi;\n  var columnsWithUpdatedDimensions = Object.keys(dimensions);\n\n  if (columnsWithUpdatedDimensions.length === 0 && orderedFields.length === 0) {\n    return columnsState;\n  }\n\n  var orderedFieldsLookup = {};\n  var cleanOrderedFields = [];\n\n  for (var i = 0; i < orderedFields.length; i += 1) {\n    var field = orderedFields[i]; // Ignores the fields in the initialState that matches no field on the current column state\n\n    if (columnsState.lookup[field]) {\n      orderedFieldsLookup[field] = true;\n      cleanOrderedFields.push(field);\n    }\n  }\n\n  var newOrderedFields = cleanOrderedFields.length === 0 ? columnsState.all : [].concat(cleanOrderedFields, _toConsumableArray(columnsState.all.filter(function (field) {\n    return !orderedFieldsLookup[field];\n  })));\n\n  var newColumnLookup = _extends({}, columnsState.lookup);\n\n  for (var _i = 0; _i < columnsWithUpdatedDimensions.length; _i += 1) {\n    var _field = columnsWithUpdatedDimensions[_i];\n    newColumnLookup[_field] = _extends({}, newColumnLookup[_field], dimensions[_field], {\n      hasBeenResized: true\n    });\n  }\n\n  var newColumnsState = {\n    all: newOrderedFields,\n    lookup: newColumnLookup\n  };\n  return newColumnsState;\n};\n/**\n * @deprecated Should have been internal only, you can inline the logic.\n */\n\nexport var getGridColDef = function getGridColDef(columnTypes, type) {\n  if (!type) {\n    return columnTypes[DEFAULT_GRID_COL_TYPE_KEY];\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!columnTypeWarnedOnce && !columnTypes[type]) {\n      console.warn([\"MUI: The column type \\\"\".concat(type, \"\\\" you are using is not supported.\"), \"Column type \\\"string\\\" is being used instead.\"].join('\\n'));\n      columnTypeWarnedOnce = true;\n    }\n  }\n\n  if (!columnTypes[type]) {\n    return columnTypes[DEFAULT_GRID_COL_TYPE_KEY];\n  }\n\n  return columnTypes[type];\n};\nexport var createColumnsState = function createColumnsState(_ref5) {\n  var apiRef = _ref5.apiRef,\n      columnsToUpsert = _ref5.columnsToUpsert,\n      initialState = _ref5.initialState,\n      columnsTypes = _ref5.columnsTypes,\n      _ref5$currentColumnVi = _ref5.currentColumnVisibilityModel,\n      currentColumnVisibilityModel = _ref5$currentColumnVi === void 0 ? gridColumnVisibilityModelSelector(apiRef) : _ref5$currentColumnVi,\n      shouldRegenColumnVisibilityModelFromColumns = _ref5.shouldRegenColumnVisibilityModelFromColumns,\n      _ref5$keepOnlyColumns = _ref5.keepOnlyColumnsToUpsert,\n      keepOnlyColumnsToUpsert = _ref5$keepOnlyColumns === void 0 ? false : _ref5$keepOnlyColumns;\n\n  var _apiRef$current$getRo, _apiRef$current$getRo2, _apiRef$current, _apiRef$current$getRo3;\n\n  var isInsideStateInitializer = !apiRef.current.state.columns;\n  var columnsStateWithoutColumnVisibilityModel;\n\n  if (isInsideStateInitializer || keepOnlyColumnsToUpsert) {\n    columnsStateWithoutColumnVisibilityModel = {\n      all: [],\n      lookup: {}\n    };\n  } else {\n    var currentState = gridColumnsSelector(apiRef.current.state);\n    columnsStateWithoutColumnVisibilityModel = {\n      all: _toConsumableArray(currentState.all),\n      lookup: _extends({}, currentState.lookup)\n    };\n  }\n\n  var columnsToUpsertLookup = {};\n  columnsToUpsert.forEach(function (newColumn) {\n    columnsToUpsertLookup[newColumn.field] = true;\n\n    if (columnsStateWithoutColumnVisibilityModel.lookup[newColumn.field] == null) {\n      // New Column\n      columnsStateWithoutColumnVisibilityModel.lookup[newColumn.field] = _extends({}, getGridColDef(columnsTypes, newColumn.type), newColumn);\n      columnsStateWithoutColumnVisibilityModel.all.push(newColumn.field);\n    } else {\n      var mergedColumn = _extends({}, columnsStateWithoutColumnVisibilityModel.lookup[newColumn.field], newColumn);\n\n      if (!mergedColumn.hasBeenResized && COLUMNS_DIMENSION_PROPERTIES.some(function (propertyName) {\n        return newColumn[propertyName] !== undefined;\n      })) {\n        mergedColumn.hasBeenResized = true;\n      }\n\n      columnsStateWithoutColumnVisibilityModel.lookup[newColumn.field] = mergedColumn;\n    }\n  });\n\n  var columnsLookupBeforePreProcessing = _extends({}, columnsStateWithoutColumnVisibilityModel.lookup);\n\n  var columnsStateWithPreProcessing = apiRef.current.unstable_applyPreProcessors('hydrateColumns', columnsStateWithoutColumnVisibilityModel); // TODO v6: remove the sync between the columns `hide` option and the model.\n\n  var columnVisibilityModel = {};\n\n  if (shouldRegenColumnVisibilityModelFromColumns) {\n    var hasModelChanged = false;\n\n    var newColumnVisibilityModel = _extends({}, currentColumnVisibilityModel);\n\n    if (isInsideStateInitializer) {\n      columnsStateWithPreProcessing.all.forEach(function (field) {\n        newColumnVisibilityModel[field] = !columnsStateWithoutColumnVisibilityModel.lookup[field].hide;\n      });\n    } else if (keepOnlyColumnsToUpsert) {\n      // At this point, `keepOnlyColumnsToUpsert` has a new meaning: keep the columns\n      // passed via `columnToUpsert` + columns added by the pre-processors. We do the following\n      // cleanup because a given column may have been removed from the `columns` prop but it still\n      // exists in the state.\n      Object.keys(newColumnVisibilityModel).forEach(function (field) {\n        if (!columnsStateWithPreProcessing.lookup[field]) {\n          delete newColumnVisibilityModel[field];\n          hasModelChanged = true;\n        }\n      });\n    }\n\n    columnsStateWithPreProcessing.all.forEach(function (field) {\n      // If neither the `columnsToUpsert` nor the pre-processors updated the column,\n      // Then we don't want to update the visibility status of the column in the model.\n      if (!columnsToUpsertLookup[field] && columnsLookupBeforePreProcessing[field] === columnsStateWithPreProcessing.lookup[field]) {\n        return;\n      } // We always assume that a column not in the model is visible by default. However, there's an\n      // edge case where the column is not in the model but it also doesn't exist in the `columns`\n      // prop, meaning that the column is being added. In that case, we assume that the column was\n      // not visible before for it be added to the model.\n\n\n      var isVisibleBefore = currentColumnVisibilityModel[field];\n\n      if (isVisibleBefore === undefined) {\n        if (isInsideStateInitializer) {\n          isVisibleBefore = true;\n        } else {\n          var _currentState = gridColumnsSelector(apiRef.current.state);\n\n          isVisibleBefore = !!_currentState.lookup[field];\n        }\n      }\n\n      var isVisibleAfter = !columnsStateWithPreProcessing.lookup[field].hide;\n\n      if (isVisibleAfter !== isVisibleBefore) {\n        hasModelChanged = true;\n        newColumnVisibilityModel[field] = isVisibleAfter;\n      }\n    });\n\n    if (hasModelChanged || isInsideStateInitializer) {\n      columnVisibilityModel = newColumnVisibilityModel;\n    } else {\n      columnVisibilityModel = currentColumnVisibilityModel;\n    }\n  } else {\n    columnVisibilityModel = currentColumnVisibilityModel;\n  }\n\n  var columnsStateWithPortableColumns = applyInitialState(columnsStateWithPreProcessing, initialState);\n\n  var columnsState = _extends({}, columnsStateWithPortableColumns, {\n    columnVisibilityModel: columnVisibilityModel\n  });\n\n  return hydrateColumnsWidth(columnsState, (_apiRef$current$getRo = (_apiRef$current$getRo2 = (_apiRef$current = apiRef.current).getRootDimensions) == null ? void 0 : (_apiRef$current$getRo3 = _apiRef$current$getRo2.call(_apiRef$current)) == null ? void 0 : _apiRef$current$getRo3.viewportInnerSize.width) != null ? _apiRef$current$getRo : 0);\n};\nexport var mergeColumnsState = function mergeColumnsState(columnsState) {\n  return function (state) {\n    return _extends({}, state, {\n      columns: columnsState\n    });\n  };\n};","map":{"version":3,"sources":["/Users/kostadindev/PycharmProjects/rfc_qa_generation/recursive-qa/frontend/node_modules/@mui/x-data-grid/hooks/features/columns/gridColumnsUtils.js"],"names":["_extends","DEFAULT_GRID_COL_TYPE_KEY","getGridDefaultColumnTypes","gridColumnsSelector","gridColumnVisibilityModelSelector","clamp","COLUMNS_DIMENSION_PROPERTIES","computeColumnTypes","customColumnTypes","mergedColumnTypes","Object","entries","forEach","colType","colTypeDef","extendType","computeFlexColumnsWidth","initialFreeSpace","totalFlexUnits","flexColumns","flexColumnsLookup","all","frozenFields","freeze","field","value","frozen","push","loopOverFlexItems","length","violationsLookup","min","max","remainingFreeSpace","flexUnits","totalViolation","computedWidth","flex","i","column","widthPerFlexUnit","minWidth","maxWidth","keys","hydrateColumnsWidth","rawState","viewportInnerWidth","columnsLookup","widthAllocatedBeforeFlex","columnField","newColumn","lookup","columnVisibilityModel","width","Math","computedColumnWidths","columnTypeWarnedOnce","applyInitialState","columnsState","initialState","orderedFields","dimensions","columnsWithUpdatedDimensions","orderedFieldsLookup","cleanOrderedFields","newOrderedFields","filter","newColumnLookup","hasBeenResized","newColumnsState","getGridColDef","columnTypes","type","process","env","NODE_ENV","console","warn","join","createColumnsState","apiRef","columnsToUpsert","columnsTypes","currentColumnVisibilityModel","shouldRegenColumnVisibilityModelFromColumns","keepOnlyColumnsToUpsert","_apiRef$current$getRo","_apiRef$current$getRo2","_apiRef$current","_apiRef$current$getRo3","isInsideStateInitializer","current","state","columns","columnsStateWithoutColumnVisibilityModel","currentState","columnsToUpsertLookup","mergedColumn","some","propertyName","undefined","columnsLookupBeforePreProcessing","columnsStateWithPreProcessing","unstable_applyPreProcessors","hasModelChanged","newColumnVisibilityModel","hide","isVisibleBefore","isVisibleAfter","columnsStateWithPortableColumns","getRootDimensions","call","viewportInnerSize","mergeColumnsState"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { DEFAULT_GRID_COL_TYPE_KEY, getGridDefaultColumnTypes } from '../../../models';\nimport { gridColumnsSelector, gridColumnVisibilityModelSelector } from './gridColumnsSelector';\nimport { clamp } from '../../../utils/utils';\nexport const COLUMNS_DIMENSION_PROPERTIES = ['maxWidth', 'minWidth', 'width', 'flex'];\nexport const computeColumnTypes = (customColumnTypes = {}) => {\n  const mergedColumnTypes = _extends({}, getGridDefaultColumnTypes());\n\n  Object.entries(customColumnTypes).forEach(([colType, colTypeDef]) => {\n    if (mergedColumnTypes[colType]) {\n      mergedColumnTypes[colType] = _extends({}, mergedColumnTypes[colType], colTypeDef);\n    } else {\n      mergedColumnTypes[colType] = _extends({}, mergedColumnTypes[colTypeDef.extendType || DEFAULT_GRID_COL_TYPE_KEY], colTypeDef);\n    }\n  });\n  return mergedColumnTypes;\n};\n/**\n * Computes width for flex columns.\n * Based on CSS Flexbox specification:\n * https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n */\n\nexport function computeFlexColumnsWidth({\n  initialFreeSpace,\n  totalFlexUnits,\n  flexColumns\n}) {\n  const flexColumnsLookup = {\n    all: {},\n    frozenFields: [],\n    freeze: field => {\n      const value = flexColumnsLookup.all[field];\n\n      if (value && value.frozen !== true) {\n        flexColumnsLookup.all[field].frozen = true;\n        flexColumnsLookup.frozenFields.push(field);\n      }\n    }\n  }; // Step 5 of https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n\n  function loopOverFlexItems() {\n    // 5a: If all the flex items on the line are frozen, free space has been distributed.\n    if (flexColumnsLookup.frozenFields.length === flexColumns.length) {\n      return;\n    }\n\n    const violationsLookup = {\n      min: {},\n      max: {}\n    };\n    let remainingFreeSpace = initialFreeSpace;\n    let flexUnits = totalFlexUnits;\n    let totalViolation = 0; // 5b: Calculate the remaining free space\n\n    flexColumnsLookup.frozenFields.forEach(field => {\n      remainingFreeSpace -= flexColumnsLookup.all[field].computedWidth;\n      flexUnits -= flexColumnsLookup.all[field].flex;\n    });\n\n    for (let i = 0; i < flexColumns.length; i += 1) {\n      const column = flexColumns[i];\n\n      if (flexColumnsLookup.all[column.field] && flexColumnsLookup.all[column.field].frozen === true) {\n        // eslint-disable-next-line no-continue\n        continue;\n      } // 5c: Distribute remaining free space proportional to the flex factors\n\n\n      const widthPerFlexUnit = remainingFreeSpace / flexUnits;\n      let computedWidth = widthPerFlexUnit * column.flex; // 5d: Fix min/max violations\n\n      if (computedWidth < column.minWidth) {\n        totalViolation += column.minWidth - computedWidth;\n        computedWidth = column.minWidth;\n        violationsLookup.min[column.field] = true;\n      } else if (computedWidth > column.maxWidth) {\n        totalViolation += column.maxWidth - computedWidth;\n        computedWidth = column.maxWidth;\n        violationsLookup.max[column.field] = true;\n      }\n\n      flexColumnsLookup.all[column.field] = {\n        frozen: false,\n        computedWidth,\n        flex: column.flex\n      };\n    } // 5e: Freeze over-flexed items\n\n\n    if (totalViolation < 0) {\n      // Freeze all the items with max violations\n      Object.keys(violationsLookup.max).forEach(field => {\n        flexColumnsLookup.freeze(field);\n      });\n    } else if (totalViolation > 0) {\n      // Freeze all the items with min violations\n      Object.keys(violationsLookup.min).forEach(field => {\n        flexColumnsLookup.freeze(field);\n      });\n    } else {\n      // Freeze all items\n      flexColumns.forEach(({\n        field\n      }) => {\n        flexColumnsLookup.freeze(field);\n      });\n    } // 5f: Return to the start of this loop\n\n\n    loopOverFlexItems();\n  }\n\n  loopOverFlexItems();\n  return flexColumnsLookup.all;\n}\n/**\n * Compute the `computedWidth` (ie: the width the column should have during rendering) based on the `width` / `flex` / `minWidth` / `maxWidth` properties of `GridColDef`.\n * The columns already have been merged with there `type` default values for `minWidth`, `maxWidth` and `width`, thus the `!` for those properties below.\n * TODO: Unit test this function in depth and only keep basic cases for the whole grid testing.\n * TODO: Improve the `GridColDef` typing to reflect the fact that `minWidth` / `maxWidth` and `width` can't be null after the merge with the `type` default values.\n */\n\nexport const hydrateColumnsWidth = (rawState, viewportInnerWidth) => {\n  const columnsLookup = {};\n  let totalFlexUnits = 0;\n  let widthAllocatedBeforeFlex = 0;\n  const flexColumns = []; // For the non-flex columns, compute their width\n  // For the flex columns, compute there minimum width and how much width must be allocated during the flex allocation\n\n  rawState.all.forEach(columnField => {\n    const newColumn = _extends({}, rawState.lookup[columnField]);\n\n    if (rawState.columnVisibilityModel[columnField] === false) {\n      newColumn.computedWidth = 0;\n    } else {\n      let computedWidth;\n\n      if (newColumn.flex && newColumn.flex > 0) {\n        totalFlexUnits += newColumn.flex;\n        computedWidth = 0;\n        flexColumns.push(newColumn);\n      } else {\n        computedWidth = clamp(newColumn.width, newColumn.minWidth, newColumn.maxWidth);\n      }\n\n      widthAllocatedBeforeFlex += computedWidth;\n      newColumn.computedWidth = computedWidth;\n    }\n\n    columnsLookup[columnField] = newColumn;\n  });\n  const initialFreeSpace = Math.max(viewportInnerWidth - widthAllocatedBeforeFlex, 0); // Allocate the remaining space to the flex columns\n\n  if (totalFlexUnits > 0 && viewportInnerWidth > 0) {\n    const computedColumnWidths = computeFlexColumnsWidth({\n      initialFreeSpace,\n      totalFlexUnits,\n      flexColumns\n    });\n    Object.keys(computedColumnWidths).forEach(field => {\n      columnsLookup[field].computedWidth = computedColumnWidths[field].computedWidth;\n    });\n  }\n\n  return _extends({}, rawState, {\n    lookup: columnsLookup\n  });\n};\nlet columnTypeWarnedOnce = false;\n/**\n * Apply the order and the dimensions of the initial state.\n * The columns not registered in `orderedFields` will be placed after the imported columns.\n */\n\nexport const applyInitialState = (columnsState, initialState) => {\n  if (!initialState) {\n    return columnsState;\n  }\n\n  const {\n    orderedFields = [],\n    dimensions = {}\n  } = initialState;\n  const columnsWithUpdatedDimensions = Object.keys(dimensions);\n\n  if (columnsWithUpdatedDimensions.length === 0 && orderedFields.length === 0) {\n    return columnsState;\n  }\n\n  const orderedFieldsLookup = {};\n  const cleanOrderedFields = [];\n\n  for (let i = 0; i < orderedFields.length; i += 1) {\n    const field = orderedFields[i]; // Ignores the fields in the initialState that matches no field on the current column state\n\n    if (columnsState.lookup[field]) {\n      orderedFieldsLookup[field] = true;\n      cleanOrderedFields.push(field);\n    }\n  }\n\n  const newOrderedFields = cleanOrderedFields.length === 0 ? columnsState.all : [...cleanOrderedFields, ...columnsState.all.filter(field => !orderedFieldsLookup[field])];\n\n  const newColumnLookup = _extends({}, columnsState.lookup);\n\n  for (let i = 0; i < columnsWithUpdatedDimensions.length; i += 1) {\n    const field = columnsWithUpdatedDimensions[i];\n    newColumnLookup[field] = _extends({}, newColumnLookup[field], dimensions[field], {\n      hasBeenResized: true\n    });\n  }\n\n  const newColumnsState = {\n    all: newOrderedFields,\n    lookup: newColumnLookup\n  };\n  return newColumnsState;\n};\n/**\n * @deprecated Should have been internal only, you can inline the logic.\n */\n\nexport const getGridColDef = (columnTypes, type) => {\n  if (!type) {\n    return columnTypes[DEFAULT_GRID_COL_TYPE_KEY];\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!columnTypeWarnedOnce && !columnTypes[type]) {\n      console.warn([`MUI: The column type \"${type}\" you are using is not supported.`, `Column type \"string\" is being used instead.`].join('\\n'));\n      columnTypeWarnedOnce = true;\n    }\n  }\n\n  if (!columnTypes[type]) {\n    return columnTypes[DEFAULT_GRID_COL_TYPE_KEY];\n  }\n\n  return columnTypes[type];\n};\nexport const createColumnsState = ({\n  apiRef,\n  columnsToUpsert,\n  initialState,\n  columnsTypes,\n  currentColumnVisibilityModel = gridColumnVisibilityModelSelector(apiRef),\n  shouldRegenColumnVisibilityModelFromColumns,\n  keepOnlyColumnsToUpsert = false\n}) => {\n  var _apiRef$current$getRo, _apiRef$current$getRo2, _apiRef$current, _apiRef$current$getRo3;\n\n  const isInsideStateInitializer = !apiRef.current.state.columns;\n  let columnsStateWithoutColumnVisibilityModel;\n\n  if (isInsideStateInitializer || keepOnlyColumnsToUpsert) {\n    columnsStateWithoutColumnVisibilityModel = {\n      all: [],\n      lookup: {}\n    };\n  } else {\n    const currentState = gridColumnsSelector(apiRef.current.state);\n    columnsStateWithoutColumnVisibilityModel = {\n      all: [...currentState.all],\n      lookup: _extends({}, currentState.lookup)\n    };\n  }\n\n  const columnsToUpsertLookup = {};\n  columnsToUpsert.forEach(newColumn => {\n    columnsToUpsertLookup[newColumn.field] = true;\n\n    if (columnsStateWithoutColumnVisibilityModel.lookup[newColumn.field] == null) {\n      // New Column\n      columnsStateWithoutColumnVisibilityModel.lookup[newColumn.field] = _extends({}, getGridColDef(columnsTypes, newColumn.type), newColumn);\n      columnsStateWithoutColumnVisibilityModel.all.push(newColumn.field);\n    } else {\n      const mergedColumn = _extends({}, columnsStateWithoutColumnVisibilityModel.lookup[newColumn.field], newColumn);\n\n      if (!mergedColumn.hasBeenResized && COLUMNS_DIMENSION_PROPERTIES.some(propertyName => newColumn[propertyName] !== undefined)) {\n        mergedColumn.hasBeenResized = true;\n      }\n\n      columnsStateWithoutColumnVisibilityModel.lookup[newColumn.field] = mergedColumn;\n    }\n  });\n\n  const columnsLookupBeforePreProcessing = _extends({}, columnsStateWithoutColumnVisibilityModel.lookup);\n\n  const columnsStateWithPreProcessing = apiRef.current.unstable_applyPreProcessors('hydrateColumns', columnsStateWithoutColumnVisibilityModel); // TODO v6: remove the sync between the columns `hide` option and the model.\n\n  let columnVisibilityModel = {};\n\n  if (shouldRegenColumnVisibilityModelFromColumns) {\n    let hasModelChanged = false;\n\n    const newColumnVisibilityModel = _extends({}, currentColumnVisibilityModel);\n\n    if (isInsideStateInitializer) {\n      columnsStateWithPreProcessing.all.forEach(field => {\n        newColumnVisibilityModel[field] = !columnsStateWithoutColumnVisibilityModel.lookup[field].hide;\n      });\n    } else if (keepOnlyColumnsToUpsert) {\n      // At this point, `keepOnlyColumnsToUpsert` has a new meaning: keep the columns\n      // passed via `columnToUpsert` + columns added by the pre-processors. We do the following\n      // cleanup because a given column may have been removed from the `columns` prop but it still\n      // exists in the state.\n      Object.keys(newColumnVisibilityModel).forEach(field => {\n        if (!columnsStateWithPreProcessing.lookup[field]) {\n          delete newColumnVisibilityModel[field];\n          hasModelChanged = true;\n        }\n      });\n    }\n\n    columnsStateWithPreProcessing.all.forEach(field => {\n      // If neither the `columnsToUpsert` nor the pre-processors updated the column,\n      // Then we don't want to update the visibility status of the column in the model.\n      if (!columnsToUpsertLookup[field] && columnsLookupBeforePreProcessing[field] === columnsStateWithPreProcessing.lookup[field]) {\n        return;\n      } // We always assume that a column not in the model is visible by default. However, there's an\n      // edge case where the column is not in the model but it also doesn't exist in the `columns`\n      // prop, meaning that the column is being added. In that case, we assume that the column was\n      // not visible before for it be added to the model.\n\n\n      let isVisibleBefore = currentColumnVisibilityModel[field];\n\n      if (isVisibleBefore === undefined) {\n        if (isInsideStateInitializer) {\n          isVisibleBefore = true;\n        } else {\n          const currentState = gridColumnsSelector(apiRef.current.state);\n          isVisibleBefore = !!currentState.lookup[field];\n        }\n      }\n\n      const isVisibleAfter = !columnsStateWithPreProcessing.lookup[field].hide;\n\n      if (isVisibleAfter !== isVisibleBefore) {\n        hasModelChanged = true;\n        newColumnVisibilityModel[field] = isVisibleAfter;\n      }\n    });\n\n    if (hasModelChanged || isInsideStateInitializer) {\n      columnVisibilityModel = newColumnVisibilityModel;\n    } else {\n      columnVisibilityModel = currentColumnVisibilityModel;\n    }\n  } else {\n    columnVisibilityModel = currentColumnVisibilityModel;\n  }\n\n  const columnsStateWithPortableColumns = applyInitialState(columnsStateWithPreProcessing, initialState);\n\n  const columnsState = _extends({}, columnsStateWithPortableColumns, {\n    columnVisibilityModel\n  });\n\n  return hydrateColumnsWidth(columnsState, (_apiRef$current$getRo = (_apiRef$current$getRo2 = (_apiRef$current = apiRef.current).getRootDimensions) == null ? void 0 : (_apiRef$current$getRo3 = _apiRef$current$getRo2.call(_apiRef$current)) == null ? void 0 : _apiRef$current$getRo3.viewportInnerSize.width) != null ? _apiRef$current$getRo : 0);\n};\nexport const mergeColumnsState = columnsState => state => _extends({}, state, {\n  columns: columnsState\n});"]},"metadata":{},"sourceType":"module"}